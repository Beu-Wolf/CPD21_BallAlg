# Notes

## Truths
1. Being f(n) the number of nodes in the tree generated by this algorithm with n points, we have that `f(n) = 2n-1`
    
    Base case: `f(2) = 2*2-1 = 3`
    one center will be found between the two points. We will have 3 (`2*2-1`) nodes

    Induction step:
    assuming `f(n) = 2n-1`
    With one extra node we will need two more nodes: one center and the new point,
    the number of nodes will be `f(n) + 2 = 2n - 1 + 2 = 2(n+1) - 1`


## ID attribution
Each iteration will produce at least one node.
In each "iteration" we split the problem in 2 smaller sub problems (left and right) with lx and rx points, respectively.
Each of those smaller subproblems will have `2y-1` nodes (see 1.), being y = lx or rx, depending on which partition we are operating

Given the current node ID id, we can assign
 * to "left":  the range [    id+1, id +    (2lx-1)]
 * to "right": the range [id+(2lx), id + 2(lx+rx-1)] // (we don't really care about the upper limit here

This way we won't need to synchronize the workers


## Orthogonal projection marosca
We calculate the orthogonal projection to determine (with the arbitrary first coordinate of the projection)
to which partition assign a specific point. Therefore we don't need to store the orthogonal projections nor
the other coordinates of the projection


## On Distance Calculation
sqrt is an expensive operation. We can work with squared distances since they will maintain order.
when printing the nodes we just need to consider that these distances are squared
